#include <fstream>
#include <limits>
#include <unordered_map>
using namespace std;
class GATE 	//simulate a gate with its input and outputs
{
	private:
	string name="";
	int n_inp;
	string out="";
	string *in;
	int i=0;
	public:
	GATE(string s,int no)
	{
		name=s;
		n_inp=no;
		in=new string[n_inp];
	}
	void set_out(string o)
	{
		out=o;
	}
	void set_in(string s)
	{
		in[i]=s;
		i++;	
	}
	string get_in(int ind)
	{
		return in[ind];
	}
	int get_n_inp()
	{
		return n_inp;
	}
	string get_out()
	{
		return out;
	}
	string get_name()
	{
		return name;
	}
};
class Node
{
	private:
	Node* prev;
	Node* next=nullptr;
	GATE* val;
	public:
	Node(Node* a,GATE* c)
	{
		prev=a;
		val=c;
	}
	void set_next(Node* a)
	{
		next=a;
	}
	Node* get_prev()
	{
		return prev;
	}
	GATE* get_val()
	{
		return val;
	}
};
class List 	//create a linked list to store pointers of GATE type
{
	private:
	Node* last=nullptr;
	public:
	void push_back(GATE* a)
	{
		if(last!=nullptr)
		{
			Node *temp=new Node(last,a);
			last->set_next(temp);
			last=temp;
		}
		else
		{
			Node *temp=new Node(last,a);
			last=temp;
		}
	}
	Node* go_back()
	{
		last=last->get_prev();
		return last;		
	}
	Node* get_last()
	{
		return last;
	}			
};
class CIRCUIT
{
	private:
	#define max(a,b) ((a>b)? a:b)
	#define min(a,b) ((a<b)? a:b)
	unordered_map <string,float> lit; 	 //map from literals to their delays
	unordered_map <string,float> gates; 	//map from gates to their delays
	string i_line="";
	string o_line="";	
	List ls;
	void read_gate(string gate)	 //provided the line containing the i/o of the gate, updates the map of literals
	{
		static int x=-1;
		string g_name="";
		string no_in="";
		int ind=0;
		for(char ch:gate)
		{
			ind++;
			if(ch==' ')
			{
				break;
			}
			if(isdigit(ch))
			{
				no_in+=ch;
			}
			g_name+=ch;
		}
		GATE *pt;
		int i=1;
		if(no_in!="")
		{
			i=(int)(stof(no_in));
		}
		pt=new GATE(g_name,i);
		int delay=0;
		string literal="";
		while(i)
		{
			literal="";
			while(gate[ind]!=' ')
			{
				literal+=gate[ind];
				ind++;
			}
			ind++;
			delay=max(delay,lit[literal]);
			pt->set_in(literal);
			i--;
		}
		delay+=gates[g_name];
		literal="";
		while(gate[ind]!='\r' and gate[ind]!='\0')
		{
			literal+=gate[ind];
			ind++;
		}	
		pt->set_out(literal);
		ls.push_back(pt);
		lit[literal]=delay;
	}
	void print_out() 		//writes the output file
	{
		ofstream o_delays("output_delays.txt");
		int ind=15;
		string literal="";
		while((o_line[ind]!='\r') and (o_line[ind]!='\0'))
		{
			ind++;
			literal="";
			while((o_line[ind]!=' ') and (o_line[ind]!='\r') and (o_line[ind]!='\0'))
			{
				literal+=o_line[ind];
				ind++;
			}
			o_delays<<literal<<" "<<lit[literal]<<endl;
		}
		o_delays.close();	
	}
	void read_inp(string inp)		//provided the line containing the primary inputs,stores them in the map
	{
		int ind=14;
		string literal="";
		while((inp[ind]!='\r') and (inp[ind]!='\0'))
		{
			ind++;
			literal="";
			while((inp[ind]!=' ') and (inp[ind]!='\r') and (inp[ind]!='\0'))
			{
				literal+=inp[ind];
				ind++;
			}
			lit[literal]=0;
		}
	}
	bool isspace(char *c)
	{
		bool f=1;
		int i=0;
		char ch;
		while((c[i]!='\r') and (c[i]!='\0'))
		{	
			ch=c[i];
			if((ch!='\t') and (ch!=' ') and (ch!='\v') and (ch!='\f'))
				f=0;
			i++;
		}
		return f;
	}
	public:
	void set_req_del()	//sets the primary output delays
	{
		ifstream req_del("required_delays.txt");
		for(auto &x:lit)
		{
			x.second=(numeric_limits<float>::infinity());
		}
		char line[100];
		while(req_del.getline(line,100))
		{	
			if((line[0]=='/' and line[1]=='/') or (line[0]=='\r') or isspace(line))
			{
				continue;
			}
			string s1="";
			string s2="";
			int i=0;
			while(line[i]!=' ')
			{
				s1=s1+line[i];
				i++;
			}
			while(line[i])
			{
				s2=s2+line[i];
				i++;
			}
			lit[s1]=stof(s2);
		}
		req_del.close();
	}
	void set_gates()		//sets all the delay timings of the gates to the ones provided in the file.
	{
		ifstream g_delays("gate_delays.txt");
		char line[100];
		while(g_delays.getline(line,100))
		{	
			if((line[0]=='/' and line[1]=='/') or (line[0]=='\r') or isspace(line))
			{
				continue;
			}
			string s1="";
			string s2="";
			int i=0;
			while(line[i]!=' ')
			{
				s1=s1+line[i];
				i++;
			}
			while(line[i])
			{
				s2=s2+line[i];
				i++;
			}
			gates[s1]=stof(s2);
		}
		g_delays.close();
	}	
	void mk_circ()		//reads the circuit file
	{
		ifstream net("circuit.txt");
		char line[100];	
		while(net.getline(line,100))
		{	
			
			if((line[0]=='/' and line[1]=='/') or (line[0]=='\r') or isspace(line))
			{
				continue;
			}
			string s1="";
			int i=0;
			while(line[i]!=' ')
			{
				s1=s1+line[i];
				i++;
			}
			if(s1=="PRIMARY_OUTPUTS")
			{
				o_line=line;
			}
			else if(s1=="PRIMARY_INPUTS")
			{
				i_line=line;
				read_inp(line);
			}
			else if(s1=="INTERNAL_SIGNALS")
			{
				
			}
			else
			{
				read_gate(line);
			}
		}
		net.close();
		print_out();				
	}
	void print_in()
	{
		ofstream i_delays("input_delays.txt");
		int ind=14;
		string literal="";
		while((i_line[ind]!='\r') and (i_line[ind]!='\0'))
		{
			ind++;
			literal="";
			while((i_line[ind]!=' ') and (i_line[ind]!='\r') and (i_line[ind]!='\0'))
			{
				literal+=i_line[ind];
				ind++;
			}
			i_delays<<literal<<" "<<lit[literal]<<endl;
		}
		i_delays.close();
	}
	void calc_inp()
	{
		Node* it=ls.get_last();
		GATE* gt;
		float delay;
		float temp;
		do
		{
			gt=it->get_val();
			for(int i=0;i<gt->get_n_inp();i++)
			{
				temp=lit[gt->get_out()]-gates[gt->get_name()];
				delay=min(temp,lit[gt->get_in(i)]);
				lit[gt->get_in(i)]=delay;
			}		
		}while((it=ls.go_back())!=nullptr);
	}
		
};
int main()
{
	CIRCUIT cir;
	cir.set_gates();
	cir.mk_circ();
	cir.set_req_del();
	cir.calc_inp();
	cir.print_in();
}
